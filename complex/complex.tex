\documentclass{article}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{color}
\usepackage{graphicx}
\usepackage{hyperref}

\lstset{
  basicstyle=\ttfamily,
  frame=single,
  language=Python,
  keywordstyle=\color{blue},
  commentstyle=\color{green},
  stringstyle=\color{red},
  breaklines=true
}

\title{Applications of Complex Analysis in Computer Science}
\author{Geoffrey Wang}
\date{August 2024}

\begin{document}

\maketitle

\section{Introduction}
Complex analysis is a branch of mathematics that deals with functions of complex variables. It has numerous applications in computer science, including signal processing, fluid dynamics, electromagnetic fields, and control systems. This document will illustrate these applications with Python code examples and explain the underlying mathematical principles.

\section{Complex Number Operations}
In Python, complex numbers are natively supported. A complex number \( z \) is expressed as \( z = a + bi \), where \( a \) is the real part, \( b \) is the imaginary part, and \( i \) is the imaginary unit, satisfying \( i^2 = -1 \).

\subsection{Basic Operations}
Basic operations such as addition, multiplication, and division can be performed on complex numbers. The magnitude (or modulus) of a complex number \( z = a + bi \) is given by:

\[
|z| = \sqrt{a^2 + b^2}
\]

The conjugate of \( z \) is \( \bar{z} = a - bi \).

\begin{lstlisting}[caption={complex_number_operations.py -- Basic Complex Number Operations}, label=code:complex_number_operations]
# Complex numbers in Python
z1 = 2 + 3j
z2 = 4 - 2j

# Addition
z_add = z1 + z2

# Multiplication
z_mul = z1 * z2

# Division
z_div = z1 / z2

# Magnitude
z_mag = abs(z1)

# Conjugate
z_conj = z1.conjugate()

print(f"Addition: {z_add}")
print(f"Multiplication: {z_mul}")
print(f"Division: {z_div}")
print(f"Magnitude: {z_mag}")
print(f"Conjugate: {z_conj}")
\end{lstlisting}

\section{Mandelbrot Set}
The Mandelbrot set is a famous fractal defined in the complex plane. It is generated by iterating the complex function:

\[
z_{n+1} = z_n^2 + c
\]

where \( z_0 = 0 \) and \( c \) is a complex number. A point \( c \) belongs to the Mandelbrot set if the sequence \( z_n \) does not tend to infinity as \( n \) increases.

\begin{lstlisting}[caption={mandelbrot_set.py -- Generating the Mandelbrot Set}, label=code:mandelbrot_set]
import numpy as np
import matplotlib.pyplot as plt

def mandelbrot(c, max_iter):
    z = c
    for n in range(max_iter):
        if abs(z) > 2:
            return n
        z = z*z + c
    return max_iter

# Image size (pixels)
width, height = 800, 800

# Plot window
re_min, re_max = -2.0, 1.0
im_min, im_max = -1.5, 1.5

# Prepare the image array
image = np.zeros((height, width))

for x in range(width):
    for y in range(height):
        # Convert pixel coordinate to complex number
        c = complex(re_min + (x / width) * (re_max - re_min),
                    im_min + (y / height) * (im_max - im_min))
        # Compute the color value
        image[y, x] = mandelbrot(c, 256)

# Display the Mandelbrot set
plt.imshow(image, extent=[re_min, re_max, im_min, im_max], cmap='hot')
plt.colorbar()
plt.title("Mandelbrot Set")
plt.show()
\end{lstlisting}

\section{Laplace Transform}
The Laplace transform is a powerful tool in control theory, signal processing, and differential equations. It converts a time-domain function \( f(t) \) into a complex frequency-domain function \( F(s) \). The Laplace transform is defined as:

\[
F(s) = \mathcal{L}\{f(t)\} = \int_0^{\infty} f(t) e^{-st} \, dt
\]

where \( s \) is a complex variable.

\subsection{Application in Control Systems}
In control systems, the Laplace transform is used to analyze system stability and design controllers. The transform helps to convert differential equations into algebraic equations, which are easier to solve.

\begin{lstlisting}[caption={laplace_transform.py -- Computing the Laplace Transform}, label=code:laplace_transform]
import sympy as sp

t = sp.symbols('t')
s = sp.symbols('s')
f = sp.exp(-2 * t) * sp.sin(3 * t)

# Laplace Transform
F = sp.laplace_transform(f, t, s)

print(f"Laplace Transform of f(t): {F}")
\end{lstlisting}

\section{Fast Fourier Transform (FFT)}
The Fourier transform converts a time-domain signal into its frequency-domain representation. The Fast Fourier Transform (FFT) is an efficient algorithm to compute the Discrete Fourier Transform (DFT), which is defined as:

\[
X(k) = \sum_{n=0}^{N-1} x(n) \cdot e^{-j \frac{2\pi}{N} kn}
\]

where \( x(n) \) is the time-domain signal, and \( X(k) \) is the frequency-domain signal.

\subsection{Application in Signal Processing}
In signal processing, FFT is used to analyze the frequency components of signals, filter noise, and compress data.

\begin{lstlisting}[caption={fft_signal_processing.py -- Fast Fourier Transform}, label=code:fft_signal_processing]
import numpy as np
import matplotlib.pyplot as plt

# Generate a signal with two frequency components
sampling_rate = 1000
t = np.linspace(0, 1, sampling_rate)
signal = np.sin(2 * np.pi * 50 * t) + np.sin(2 * np.pi * 120 * t)

# Perform the FFT
fft_signal = np.fft.fft(signal)
frequencies = np.fft.fftfreq(len(fft_signal), 1/sampling_rate)

# Plot the frequency spectrum
plt.plot(frequencies[:len(frequencies)//2], np.abs(fft_signal)[:len(frequencies)//2])
plt.title("Frequency Spectrum")
plt.xlabel("Frequency (Hz)")
plt.ylabel("Magnitude")
plt.show()
\end{lstlisting}

\section{Conformal Mapping}
Conformal mapping is a technique in complex analysis that maps one domain in the complex plane to another while preserving angles. A common example is the power mapping:

\[
w = f(z) = z^2
\]

\subsection{Application in Fluid Dynamics}
In fluid dynamics, conformal mapping is used to solve potential flow problems, where the flow pattern around an object can be analyzed by mapping the complex plane.

\begin{lstlisting}[caption={conformal_mapping.py -- Conformal Mapping Implementation}, label=code:conformal_mapping]
import numpy as np
import matplotlib.pyplot as plt

def conformal_map(z):
    return z**2

# Create a grid in the complex plane
re = np.linspace(-2, 2, 400)
im = np.linspace(-2, 2, 400)
re, im = np.meshgrid(re, im)
z = re + 1j * im

# Apply the conformal map
w = conformal_map(z)

# Plot the original grid
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.contour(re, im, np.abs(z), colors='black', linestyles='solid')
plt.title("Original Grid")

# Plot the mapped grid
plt.subplot(1, 2, 2)
plt.contour(w.real, w.imag, np.abs(w), colors='black', linestyles='solid')
plt.title("Mapped Grid")

plt.show()
\end{lstlisting}

\section{Conclusion}
- **Complex Number Operations**: Involves basic arithmetic operations, magnitude, and conjugate operations, which are widely used in signal processing and control systems.
- **Mandelbrot Set**: Generated through iterative complex functions, used to study the behavior of iterative processes in the complex plane.
- **Laplace Transform**: Converts time-domain signals into the complex frequency domain, essential in control theory and signal processing.
- **Fast Fourier Transform (FFT)**: Efficiently transforms discrete time-domain signals into their frequency domain, involving complex number calculations.
- **Conformal Mapping**: Used in complex analysis to map one domain in the complex plane to another while preserving angles, important in fluid dynamics and other fields.

These Python examples demonstrate how complex analysis can be applied in computer science, providing a wide range of applications from basic complex number operations to advanced mappings and transformations.

\end{document}
